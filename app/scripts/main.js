// Generated by CoffeeScript 1.12.5
var p2;

p2 = require('p2');

module.exports = function(es, out) {
  var connections, lastTime, ph, playerUpdated, players, random, randomSymbs, startTime, state, timeStep, tokens, world;
  connections = {};
  players = {};
  tokens = {};
  playerUpdated = function(c, player) {
    return c.playerUpdated({
      name: player.name,
      count: player.count,
      x: player.x,
      y: player.y,
      connectionID: player.connectionID
    });
  };
  startTime = (new Date).getTime();
  lastTime = void 0;
  timeStep = 1 / 70;
  world = new p2.World({
    gravity: [0, 0]
  });
  ph = function() {
    var currentTime, dt, timeElapsed;
    currentTime = (new Date).getTime();
    timeElapsed = currentTime - startTime;
    dt = lastTime ? timeElapsed - lastTime / 100 : 0;
    dt = Math.min(1 / 10, dt);
    return world.step(timeStep);
  };
  setInterval(ph, 1000 / 60);
  state = {
    open: true,
    closed: false,
    setOpened: function(s) {
      if (typeof s !== 'boolean') {
        state.open = true;
        state.closed = false;
      } else {
        state.open = s;
        state.closed = !s;
      }
      return state._onOC();
    },
    setClosed: function(s) {
      if (typeof s !== 'boolean') {
        state.closed = true;
        state.open = false;
      } else {
        state.closed = s;
        state.open = !s;
      }
      return state._onOC();
    },
    _onOC: function() {
      var _, c, player, results, results1;
      if (state.closed) {
        for (_ in connections) {
          c = connections[_];
          c.serverClosed("Sorry, but server is closed at now. You can try to connect later.");
        }
        results = [];
        for (_ in players) {
          player = players[_];
          delete players[player.name];
          delete tokens[player.name];
          results.push((function() {
            var results1;
            results1 = [];
            for (_ in connections) {
              c = connections[_];
              results1.push(c.playerRemoved(player.name));
            }
            return results1;
          })());
        }
        return results;
      } else if (state.open) {
        results1 = [];
        for (_ in connections) {
          c = connections[_];
          results1.push(c.serverOpened());
        }
        return results1;
      }
    },
    canJoin: true,
    allowJoining: function(s) {
      if (typeof s !== 'boolean') {
        return state.canJoin = true;
      } else {
        return state.canJoin = s;
      }
    },
    disallowJoining: function(s) {
      if (typeof s !== 'boolean') {
        return state.canJoin = false;
      } else {
        return state.canJoin = !s;
      }
    }
  };
  out.getAdminToken = function(name) {
    if (tokens.admin) {
      out.error("Admin's token exists.");
      return;
    }
    tokens.admin = "admin" + ':' + random(1000000000000000, 9999999999999999) + ':' + randomSymbs(30);
    out.message('Your token is "' + tokens.admin + '".\nPress "Alt+Shift+A" on main page and enter this token.\nThen enter "admin" to input and enjoy game!');
    return tokens.admin;
  };
  out.removePlayer = function(name) {
    var _, c;
    if (players[name]) {
      delete players[name];
      for (_ in connections) {
        c = connections[_];
        c.playerRemoved(name);
      }
      out.info('Removed player "' + name + '".');
    } else {
      out.error('Player "' + name + '" not exists.');
    }
    if (tokens[name]) {
      delete tokens[name];
      return out.info('Removed ' + name + '\'s token.');
    } else {
      return out.error(name + '\'s token not exists.');
    }
  };
  out.closeServer = function() {
    state.setClosed();
    return out.info('Server succefully closed!');
  };
  out.openServer = function() {
    state.setOpened();
    return out.info('Server succefully opened!');
  };
  out.allowJoining = function() {
    state.allowJoining();
    return out.info('Joining is allowed now!');
  };
  out.disallowJoining = function() {
    state.disallowJoining();
    return out.info('Joining is disallowed now!');
  };
  random = function(min, max) {
    if (!max) {
      max = min;
      min = 0;
    }
    return Math.floor(min + (Math.random() * (max - min)));
  };
  randomSymbs = function(count) {
    var result, symbs;
    symbs = "qwertyuiopasdfghjklzxcvbnm";
    result = "";
    while (result.length <= count) {
      result += symbs[random(0, symbs.length - 1)];
    }
    return result;
  };
  es.onConnect(function(c) {
    out.info('User ' + c.id + ' connected!');
    return connections[c.id] = c.clientProxy;
  });
  es.onDisconnect(function(c) {
    var _, id, player, removed, results;
    id = c.id;
    out.info('User ' + id + ' disconnected!');
    if (connections[id]) {
      delete connections[id];
    }
    removed = [];
    results = [];
    for (_ in players) {
      player = players[_];
      if (id === player.connectionID) {
        results.push(out.removePlayer(player.name));
      } else {
        results.push(void 0);
      }
    }
    return results;
  });
  es.exports.verifyUsername = function(name) {
    if (name === 'admin' || name === 'аdmin') {
      return "Username \"admin\" is reserved.";
    }
    if (!(name.length <= 20 && name.length > 3)) {
      return "Username must contain 3 symbols at least and 20 as maximum.";
    }
    if (players[name]) {
      return "Player " + name + " already in game.";
    }
    if (tokens[name]) {
      return name + "'s token exists";
    }
    if (!state.canJoin) {
      this.clientProxy.serverClosed("Sorry, but server is closed for new players at now. You can try to connect later.");
    }
    return true;
  };
  es.exports.getState = function() {
    return {
      open: state.open,
      close: state.closed,
      canJoin: state.canJoin
    };
  };
  es.exports.getToken = function(name) {
    if (!state.canJoin) {
      return;
    }
    if (!state.open) {
      return;
    }
    if (name === 'admin' || name === 'аdmin') {
      out.error("Username \"admin\" is reserved.");
    }
    if (!(name.length <= 20 && name.length > 3)) {
      out.error("Username (tried " + name + ") must contain 3 symbols at least and 20 as maximum.");
      return;
    }
    if (players[name]) {
      out.error("Player " + name + " already in game.");
      return;
    }
    if (tokens[name]) {
      out.error(name + "'s token exists.");
      return;
    }
    if (!state.canJoin) {
      return;
    }
    tokens[name] = name + ':' + random(1000000000000000, 9999999999999999) + ':' + randomSymbs(30);
    out.info('New token: ' + tokens[name]);
    return tokens[name];
  };
  es.exports.newPlayer = function(name, token) {
    var _, c, results;
    if (!state.canJoin) {
      return;
    }
    if (!state.open) {
      return;
    }
    if (!name || !token) {
      return;
    }
    if (token !== tokens[name]) {
      return;
    }
    if (players[name]) {
      out.error('Player ' + name + ' exists!');
      return;
    }
    players[name] = {
      name: name,
      count: 0,
      body: new p2.Body({
        mass: 0,
        position: [0, 0]
      }),
      connectionID: this.user.clientId
    };
    world.addBody(players[name].body);
    players[name].x = players[name].body.position[0];
    players[name].y = players[name].body.position[1];
    world.addBody(players[name].body);
    out.info('Created new player ' + name + '!');
    results = [];
    for (_ in connections) {
      c = connections[_];
      results.push(playerUpdated(c, players[name]));
    }
    return results;
  };
  es.exports.input = function(player, token, inp) {
    var _, c, results;
    if (!(tokens[player] && players[player])) {
      return;
    }
    if (tokens[player] !== token) {
      out.error(player.name + '\'s token is invalid!');
      return;
    }
    players[player].body.velocity = [0, 0];
    if (inp === "a") {
      players[player].body.velocity[0] = -400;
    }
    if (inp === "d") {
      players[player].body.velocity[0] = 400;
    }
    if (inp === "w") {
      players[player].body.velocity[1] = -400;
    }
    if (inp === "s") {
      players[player].body.velocity[1] = 400;
    }
    results = [];
    for (_ in connections) {
      c = connections[_];
      results.push(playerUpdated(c, players[player]));
    }
    return results;
  };
  return es.exports.getPlayers = function() {
    return players;
  };
};
